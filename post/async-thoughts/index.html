<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Async with rust, a collection of learnings - dev.log | de-sh speaks about code...
    </title>

    <meta name="description" content="A collection of thoughts and links that I feel have had a disproportionate impact on my journey
        learning async-rust">
    <meta name="author" content="">

    <link href="/blog/css/font.css" rel="stylesheet">
    <link href="/blog/css/atom-one-dark.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700,700i" rel="stylesheet">
    <link href="/blog/css/style.css" rel="stylesheet">

    <link rel="icon" href="/images/favicon.png">

    <meta name="generator" content="Hugo 0.55.3" />

    <link rel="alternate" type="application/atom+xml" href="/blog/index.xml" title="dev.log">

</head>

<body class="single">
    <header class="header">

        <h1 class="title"><a href="/blog/"><img src="/images/favicon.png" alt="blog"
                    style="height:50px; margin-top:-10px"></a></h1>

    </header>
    <main class="main">
        <div class="progress-bar" id="myBar"></div>
        <article class="post post-view">
            <header class="post-header">
                <h1 class="post-title">Async with rust, a collection of learnings</h1>
                <em>A collection of thoughts and links that I feel have had a disproportionate impact on my journey
                    learning async-rust</em>
                <p class="post-meta">October 15, 2021</p>
            </header>
            <div class="post-content">
                <p>I wrote my first few lines of async rust at the end of 2020, that was the first time I was actually
                    learning about the core principles behind async/await, while building a <a
                        href="https://github.com/de-sh/kvdb/commit/30f428c5263f13f6ebc3b3303d636f0c3c178ee2">toy
                        database</a>. Even though I have had prior experience writing code with similar keywords in
                    javascript and python, they didn't make much sense then, it was just what I had to write to get
                    through implementing something in code. Having been pulled into the async world while writing
                    network facing code, I found it to be a learning that also transfered well into college as we were
                    learning about similar stuff in a class on Programming Paradigmns.</p>
                <p>The journey into
                    async-rust started for me with some exposure through a well written <a
                        href="https://tokio.rs/tokio/tutorial">tutorial on the tokio project's website</a>, which
                    introduced the why in such a way that async/await totally made sense. This piece is a recollection
                    of material that I've used to make sense of and interpret the crazy complex world of async/await
                    over the past year or so. Anyways, if you are new and only getting started with rust and want to
                    learn about the basics, I'd point you to <a href="https://www.youtube.com/watch?v=ThjvMReOXYM">this
                        awesome screencast on YouTube by Jon Gjengset(@jonhoo)</a>, if you'd still like to read on and
                    learn from my journey, it's my pleasure :D</p>
                <p>Writing a lock and load mechanism for handling
                    shared memory between threads was interesting, even more interesting was learning about how
                    <code>lock()</code> in <code>std</code> differed from <code>lock()</code> in <code>tokio</code>. The
                    way in which these two handled I/O also made for an interesting comparison. How all of tokio managed
                    well with a <code>.await</code>, which until now had to be a <code>io::Result&lt;_&gt;</code> in
                    std.
                </p>
                <p>To give a brief, async-rust code looks like this:</p>
                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
async fn hello() -> String {
    // Code that waits on some IO
}

fn main() {
    let runtime = runtime_builder(); // Creates a runtime for async operations
    print!("{}", runtime.on_block(async { hello().await})); // Calls the function from within built runtime and blocks main() till it returns
}
                </code></pre>
                <p>What happens here is simple, we have an async function <code>hello()</code>
                    running from within a runtime that blocks <code>main()</code>. Wait, so what's an async function and
                    how is it different from the regular function? Well, they are similar in how they are written, but
                    differ in that an async function starts with the keywords <code>async fn</code> unlike the normal
                    <code>fn</code>, here <code>async</code> is syntactic sugar that translates down as depicted below:
                </p>
                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
async fn hello() -> String {
    // Logic
}
                </code></pre>
                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
fn hello() -> Future&lt;Output = String&gt; {
    // Logic
}
                </code></pre>
                <p>till the &quot;future&quot; returns, in which case the value is then
                    printed to screen by <code>print!()</code>. There's a lot of thought that has gone into how
                    async/await within runtimes is a lot better than callbacks that have to be handled manually(as was
                    once the norm, <em>casually points to javascript's <code>.then()</code></em>), a debate I am not
                    going to expand upon. Here's take where this problem is presented in a classic blog called <a
                        href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">&quot;What
                        color is your function&quot;</a>, a well articulated read if I am to recommend one, in which
                    async functions and regular functions are called colored functions that allow one to call the other,
                    but not vice versa and how things evolved till it got here.</p>
                <p>Multi-threaded apps allow you to better utilise the large number of threads that are now common in
                    newer CPUs, writing these apps on the other hand is a tough ask. With rust and async though, things
                    are significantly better. For one, you can spawn a thread with <a
                        href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>std::thread::spawn()</code></a>
                    and have part of your application run on a dedicated thread. For example, a dedicated thread is a
                    great way to handle Network and IO interfaces separately from the business logic of the app, an
                    example of code written like this would be:</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
fn main() {
    std::thread::spawn(|| {
        // Code that is to be run on a separate thread
    });
    // Code to be run on the current(main) thread. e.g. loop {}
}
                </code></pre>
                <p>It is to be noted that there should be code that continues to run in the
                    main thread for the code spawned into thread to interact with the terminal, else the app just
                    returns. Thus the difference between the following two code blocks is pretty big:</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
fn main() {
    std::thread::spawn(|| {
        for i in 1..100 {
            println!(&quot;{}&quot;, i);        
        }
    });
}
                </code></pre>
                <p>Output is empty:</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">
$ ./run

                </code></pre>
                <p>As observed, above code returns as soon as the thread is spawned and doesn't print
                    to the terminal, whereas the following does print the numbers 1 through 99.</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
fn main() {
    std::thread::spawn(|| {
        for i in 1..100 {
            println!(&quot;{}&quot;, i);    
        }
    });
    
    loop {}
}
                </code></pre>
                <p>Output contains numbers 1 through 99 in order and blocks the terminal
                    afterwards, due to the <code>loop {}</code> statement:</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">
$ ./run
1
2
3
...
99
                </code></pre>
                <p>Similarly, if you are constrained by the number of threads you can
                    spawn(depending on the OS), an intelligent way to handle this problem is with <a
                        href="https://docs.rs/tokio/1.12.0/tokio/task/fn.spawn.html"><code>tokio::task::spawn()</code></a>
                    which has similar syntax, but supports async program scopes that are handled by the runtime(in this
                    case tokio) and can be scheduled to run on the same thread or a different one by using the concept
                    of <strong>green-threads</strong>. Hence when you write the following with <code>task</code>s
                    instead of <code>thread</code>s, the difference is pretty easy to determine. This in code looks
                    something like:</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
#[tokio::main]
async fn main() {
    tokio::task::spawn(async {
        // Code that is to be handled by a concurrent task
    });
    // Rest of main()
}
                </code></pre>
                <p>Since tasks are cheaper than full blown threads due to the lesser number of
                    system calls made, they are better for a lot of things and hence are more often used as far as my
                    code goes.</p>
                <blockquote>
                    <p><strong>NOTE:</strong> Threads are managed by the OS and in Linux they are preemptable.
                        This is different from how tokio does things with a non-preemptive/cooperative approach. An
                        example situation where this might become a problem is when 8 forever running tasks are
                        dispatched to run within a runtime that has only 4 threads allotted to it, 4 of these tasks will
                        never start execution given the cooperative nature by which tokio handles them.</p>
                </blockquote>

                <p>A question that might have now made it's way into your mind right now would be:
                    &quot;If I have multiple threads/tasks handling various facets of my apps operations, how do I
                    ensure that they are working in tandem and not cause chaos?&quot;, fret not, the answer I most
                    frequently relate with is the humble channel. Channels are shared memory regions that are shared
                    between multiple threads, one type of channel is the multi-producer-single-consumer <a
                        href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>std::sync::mpsc::channel</code></a>
                    which allows for multiple producer thread/tasks to send data into a single consumer thread/task. The
                    above mentioned function returns a tuple of <code>(Sender&lt;T&gt;, Receiver&lt;T&gt;)</code> where
                    the receiver can be passed on to the consumer operation and the sender to the producer operations.
                    An example where these could be used is as such:</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
fn main() {
    let (tx, rx) = std::sync::mpsc::channel();
    std::thread::spawn(move || {
        for i in 1..100 {
            tx.send(i);
        }
    });
    
    while let Ok(i) = rx.recv() {
        println!(&quot;{}&quot;, i);
    }
}
                </code></pre>
                <p>Output contains 1 to 99 in order, just as the previous example, but here we
                    are printing from <code>main()</code> instead of doing it from a spawned thread. There's a
                    possibility that not all numbers will be printed, but the app returns after printing 99 for sure:
                </p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">
$ ./run
1
2
3
...
99
                </code></pre>
                <p>Since multiple producers can exist, the code could also be:</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
fn main() {
    // Two channels are necessary to communicate with the two tasks.
    let (tx_a, rx_a) = std::sync::mpsc::channel();
    let tx_b = tx_a.clone();
    std::thread::spawn(move || {
        for i in 1..50 {
            tx_a.send(i);
        }
    });
    
    std::thread::spawn(move || {
        for i in 50..100 {
            tx_b.send(i);
        }
    });
    
    while let Ok(i) = rx_a.recv() {
        println!(&quot;{}&quot;, i);
    }
}
                </pre></code>
                <p>Output contains numbers 1 to 49 and 50 to 99 in random order, depending on
                    when they were sent onto the channel, depicting the concurrent nature of processes running on
                    threads:</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">
$ ./run
50
1
2
51
3
...
                </code></pre>
                <p>Another great feature of async code that I've come to use a lot is
                    <code>select!</code>, an async construct that performs multiplexing of async tasks. It has been very
                    helpful as far as writing concurrent, multi-threaded IO/Network heavy applications goes, a note to
                    read about and understand this is <a href="https://tokio.rs/tokio/tutorial/select">from the tokio
                        tutorial</a>. A great way to illustrate the use of <code>select!</code> is by making the
                    following changes to the last example:

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
use tokio::{select, sync::mpsc, task};

#[tokio::main]
async fn main() {
    // Two channels are necessary to communicate with the two tasks.
    let (tx_a, mut rx_a) = mpsc::channel(100);
    let (tx_b, mut rx_b) = mpsc::channel(100);
    
    task::spawn(async move {
        for i in 1..50 {
            tx_a.send(i).await;
        }
    });
    
    task::spawn(async move {
        for i in 50..100 {
            tx_b.send(i).await;
        }
    });
    
    loop {
        select! {
            Some(i) = rx_a.recv() =&gt; {
                println!(&quot;{}&quot;, i);
            }
            
            Some(i) = rx_b.recv() =&gt; {
                println!(&quot;{}&quot;, i);
            }
        }
    }
}
                </code></pre>
                <p>Output is similar to the previous example and contains numbers 1 to 49 and
                    50 to 99 in random order, depending on when they were sent onto the channel, depicting the
                    concurrent nature of processes running in the tokio tasks:</p>

                <pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">
$ ./run
1
2
3
50           
51
52
...
                </code></pre>
                <p>There's a lot more complex, but fun stuff that happens here, and a lot of this is abstracted away to
                    make the experience a breeze for beginners, but it's still well worth the time to delve into the
                    guts of this exciting coding paradigm. I for one, will be continuing to learn a lot, that's for
                    sure, until the next one, farewell friends :D</p>

                <p><strong>Edited 18th October:</strong> Added a note to differentitate between thread and tokio tasks
                    on the basis of preemption as pointed out to me by <a
                        href="https://github.com/tekjar">Ravi(@tekjar)</a>.</p>

            </div>
            <footer class="post-footer">

            </footer>
        </article>
    </main>
    <footer class="footer">
        <span>&copy; 2021 <a href="/" rel="noopener" target="_blank">Devdutt Shenoi</a>Ô∏è</span>
    </footer>
    <script src="/blog/js/site.js"></script>
</body>

</html>